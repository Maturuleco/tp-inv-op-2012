\section{Explicación}

\subsection{Cortes Cover}
\input{2_explicacion/desarrollo_cover}
\newpage
\input{2_explicacion/implementacion_cover}
\newpage

\subsection{Cortes Clique}
\input{2_explicacion/desarrollo_clique}
\newpage
\input{2_explicacion/implementacion_clique}
\newpage

\subsection{Más Comentarios}
\subsubsection{Más Comentarios: Teóricos}
Además de lo comentado anteriormente, hay que aclarar que a la hora de recorrer el árbol de subproblemas derivados del MIP original hay dos puntos clave en el que hay que elegir una estrategia de recorrido. El $CPLEX$ puede tener varios nodos (subproblemas derivados del MIP) activos (aún no se calculó su relajación lineal y no se hizo $branching$) en un mismo momento. Para elegir qué nodo es el próximo a ser analizado hay que establecer una \emph{estrategia de selección de nodo}. En el caso de este trabajo se optó por la política ``best-bound'' (elige el nodo cuya relajación tiene el valor del óptimo más conveniente). Por otra parte, para hacer $branching$ también suele establecerse una \emph{estrategia de selección de variable}. En este trabajo se eligió la política ``minimum-infeasibility'' (se elige la variable más cercana a un valor entero).\\

La idea intuitiva detrás de estas elecciones es que el recorrido en el árbol de $branching$ se encuentra con nodos de valor \emph{cercano} al óptimo y variables \emph{cercanas} a cumplir las condiciones de integralidad, por lo que el recorrido no tardará \emph{mucho} en encontrar el óptimo tras revisar un conjunto de nodos. Esta visión, de más está decirlo, es extremadamente ingenua y carece de sustento teórico conformante. Simplemente se eligieron esas políticas para que las tres técnicas algorítmicas sigan un recorrido análogo entre ellas, en vez de dejar que el $CPLEX$ tomara decisiones automáticamente. En la práctica este tipo de decisiones se toman luego de un extenso historial empírico que sugiera un favoritismo sobre determinadas estrategias; pero igualmente este enfoque puede ir variando diametralmente entre distintos MIPs.

\subsubsection{Más Comentarios: Implementación}

Se puede ver en el código presentado que se implementó un módulo \verb_Covers_ para el manejo de las desigualdades mochila para buscar cortes cover y un módulo \verb_Grafo_ para el manejo del grafo de conflictos para buscar cortes clique. Además, se implementó un módulo \verb_problemaCPLEX_ que actúa de intermediario entre aquéllos y el $CPLEX$. Esta modularización resultó de gran utilidad porque provee una independencia de implementación entre tres aspectos distintos pero que se relacionan entre sí. Un objeto \verb_problemaCPLEX_ no sólo guarda todo lo necesario para usar el $CPLEX$ (entorno, problema, status, etc), sino que además guarda un objeto \verb_Covers_ y un objeto \verb_Grafo_, de manera que hay una centralización hacia \verb_problemaCPLEX_ pero se garantiza independencia para sus propios métodos a \verb_Covers_ y \verb_Grafo_. Finalmente, en \verb_resolucion.cpp_ se tiene la interfaz entre \verb_problemaCPLEX_ y el usuario del $resolver$.\\

Se decide no ampliar la explicación del código porque son aspectos muy técnicos. El lector interesado puede tratar de comprender el código presentado usando como soporte la introducción a la \emph{CPLEX C Callable Library} expuesta en el  \emph{Apéndice}.
